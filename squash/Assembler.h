#ifndef ASSEMBLER_H
#define ASSEMBLER_H

struct Assembler;

#include "Assembly.h"
#include "AST.h"
#include "sb.h"
#include "FileIO.h"
#include "Encoder.h"

#include <stdio.h>

struct Assembler* assembler_new();

/// <summary>
/// Generates assembly language code given specified AST.
/// </summary>
/// <exception cref="Exception">
/// Underlying Assemble() method can throw exceptions as well as this method.
/// </exception>
void GenerateCode(struct Assembler* assembler, astnode_t* astNode, char* output_file_name, char* output_binary_file_name, bool enable_tracing);

void functionbody_assemble(astnode_t* node, StringBuilder* sb, struct Assembler* assembler);

void functionargs_extract_assemble(astnode_t* node, StringBuilder* sb, struct Assembler* assembler);

void functionreturn_assemble(StringBuilder* sb, struct Assembler* assembler, astnode_t* node);

void variableassignment_assemble(StringBuilder* sb, struct Assembler* assembler, astnode_t* node);

void number_assemble(StringBuilder* sb, astnode_t* node, struct Assembler* assembler);

void variable_assemble(StringBuilder* sb, astnode_t* node, struct Assembler* assembler);

void functioncall_assemble(astnode_t* node, StringBuilder* sb, struct Assembler* assembler);

void binop_assemble(StringBuilder* sb, struct Assembler* assembler, astnode_t* node);

void unaryop_assemble(StringBuilder* sb, struct Assembler* assembler, astnode_t* node);

void functionarg_assemble(StringBuilder* sb, struct Assembler* assembler, astnode_t* node);

void functiondefinition_assemble(struct Assembler* assembler, StringBuilder* sb, astnode_t* node);

void variabledefine_assemble(StringBuilder* sb, struct Assembler* assembler, astnode_t* node);

void functionbody_assemble2(astnode_t* node, StringBuilder* sb, struct Assembler* assembler);

/// <summary>
/// Assembles the specified ASTNode into assembly language instructions.
/// This is the compiler backend.
/// </summary>
/// <param name="node">
/// The specified ASTNode to compile into assembly instructions.
/// </param>
/// <returns>
/// A string comprising a set of assembly language instructions to be further assembled to machine code.
/// </returns>
/// <exception cref="Exception">
/// Can throw exceptions related to invalid ASTNodeType types.
/// </exception>
char* Assemble(struct Assembler* assembler, astnode_t* node);

/// <summary>
/// Adds data
/// </summary>
/// <param name="array">Data</param>
//void db(unsigned char* array);

struct Instruction* mov64(enum Register dst, struct AssemblerMemoryOperand* src, int Bitness);

/// <summary>
/// Adds data
/// </summary>
/// <param name="array">Data</param>
/// <param name="index">Start index</param>
/// <param name="length">Length in bytes</param>
void db(struct Assembler* assembler, unsigned char* array, int index, int length);

/// <summary>call selector:offset instruction.</summary>
void call(struct Assembler* assembler, unsigned short selector, unsigned int offset);

/// <summary>jmp selector:offset instruction.</summary>
void jmp(struct Assembler* assembler, unsigned short selector, unsigned int offset);

/// <summary>xlatb instruction.</summary>
void xlatb(struct Assembler* assembler);

/// <summary>
/// Generates multibyte NOP instructions
/// </summary>
/// <param name="sizeInBytes">Size in bytes of all nops</param>
void nop(struct Assembler* assembler, int sizeInBytes);

/// <summary>
/// Assemble the program image which is generated by the assembler into a stream of bytes.
/// </summary>
/// <param name="assembler">
/// The assembler instance.
/// </param>
/// <param name="RIP_program_start_addr">
/// The start address of the program where all operations begin executing at the specified RIP address.
/// </param>
/// <returns>
/// A stream of bytes of the effective machine code generated by the assembler.
/// </returns>
unsigned char* squash_assemble(struct Assembler* assembler, unsigned long RIP_program_start_addr, int* encoder_length);

void test_assembler();

//void squash_assembler(struct Assembler* assembler, char* source_asm, int source_size, char* output_binary_file_name);

#endif